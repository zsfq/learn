# 笔记 
## 一、关于不同版本的Vue
    1.vue.js与vue.runtime.xxx.js的区别：
        （1）vue.js是完整版的Vue,包含：核心功能 + 模板解析器
        （2）vue.runtime.xxx.js是运行版的Vue，只包含：核心功能，没有模板解析器
    
    2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体的内容。
## 二、ref属性
    1.被用来给元素或者子组件注册引用信息（id的替代者）
    2.应用在html标签上获取的是真实的DOM元素，应用在组件标签上是组件实例对象（VueComponent，简称vc）
    3.使用方式：
        打标识：<h1 ref="xxx">....<h1/> 或者 <MySchool ref="xxx"></MySchool>
        获取：this.$refs.xxx
## 三、配置项props
    功能：让组件接收外部传进来的数据
    （1）传递数据：
        <Demo name="xxx"></Demo>
    （2）接收数据：
        第一种方式（只接收）：
            props:['name']
        
        第二种方式（限制类型）：
            props:{
                name:String
            }
    
        第三种方式（限制类型、限制必要性、指定默认值）：
            props:{
                name:{
                    type:String,         //类型
                    required:true,       //必要性
                    default:'老王'       //默认值
                }
            }
        
        备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
             若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。

## 四、总结TodoList案例

1. 组件化编码流程：

   （1）拆分静态组件：组件要按照功能点拆分，命名不用与html元素冲突。

   （2）实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：

   ​		a.一个组件在用：放在自身即可。

   ​		b.一些组件在用：放在他们共同的父组件上（<span style="color:red;">状态提升</span>）

   （3）实现交互：从绑定事件开始。

2. props适用于：

   （1）父组件 ====> 子组件   通信

   （2）子组件 ====> 父组件   通信（要求父先给子一个函数）

3. 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！

4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做！！！

## 五、webStorage

1. 存储内容大小一般为5MB左右（不同浏览器可能不同）

2. 浏览器通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制

3. 相关API：

   1. `xxxxxStorage.setItem('key','value');`

      该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。

   2. `xxxxxStorage.getItem('key');`

      该方法接受一个键名作为参数，返回键名对象的值。

   3. `xxxxxStorage.removeItem('key');`

      该方法接受一个键名作为参数，并把该键名从存储中删除。

   4. `xxxxxStorage.clear()`

      该方法会清空存储中的所有数据。

4. 备注：

   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。
   2. LocalStorage存储的内容，需要手动清除才会消失。
   3. `xxxxxStorage.getItem(xxx)`如果xxx对应的value获取不到，那么getItem的返回值为null。
   4. `JSON.parse(null)`的结果依然是null。

## 六、全局事件总线（GlobalEventBus)

1. 一种组件间通信的方式，适用于<span style="color:red;">任意组件间的通信</span>。

2. 安装全局事件总线

   ```javascript
   new Vue({
   	......
   	beforeCreate(){
   		Vue.prototype.$bus = this            //安装全局事件总线，$bus就是当前应用的vm  
   	},
   	......
   })
   ```

3. 使用事件总线

   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，<span style="color:red;">事件的回调留在A组件自身。</span>

      ```javascript
      methods(){
      	demo(data){
      		......
      	}
      }
      ......
      mounted(){
      	this.$bus.$on('xxxx',this.demo)
      }
      ```

      

   2. 提供数据：`this.$bus.$emit('xxxx',数据)`

4. 最好在beforeDestroy钩子中，用$off去解绑<span style="color:red;">当前组件所用到的</span>事件。

## 七、消息订阅与发布（pubsub）

1. 一种组件间通信的方式，适用于<span style="color:red;">任意组件间的通信</span>。

2. 使用步骤：

   1. 安装pubsub：`npm i pubsub-js`

   2. 引入：`import pubsub from 'pubsub-js'`

   3. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，<span style="color:red;">事件的回调留在A组件自身。</span>

      ```javascript
      methods(){
      	demo(data){
      		......
      	}
      }
      ......
      mounted(){
      	this.pid = pubsub.subscribe('xxx',this.demo)   //订阅消息
      }
      ```

   4. 提供数据：`pubsub.publish('xxx',数据)`

   5. 最好在beforeDestroy钩子中，用`Pubsub.unsubscribe(pid)`去<span style="color:red;">取消订阅</span>。

​	**注意：**虽然这里用的是pubsub-js库，但发布-订阅是一种通信方式，还有很多其他的库也可以实现这种模式，例如mqtt.js等。